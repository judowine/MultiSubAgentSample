package com.example.data.repository

import com.example.data.database.dao.EventDao
import com.example.data.database.entity.EventEntity
import com.example.data.network.ApiException
import com.example.data.network.ConnpassApiClient
import kotlinx.coroutines.flow.Flow
import kotlinx.datetime.Instant

/**
 * Implementation of EventRepository with API + DB caching.
 *
 * Implementation by: project-orchestrator (coordinated by data-layer-architect)
 * PBI-2, Task 2.5: EventRepository implementation with caching strategy
 *
 * Caching Strategy:
 * - fetchEvents: Network-first (API → cache update → return)
 * - getEventsFromCache: Cache-only (instant return, reactive Flow)
 * - getEventById: Cache-first with API fallback
 *
 * Error Handling:
 * - Network errors: Fall back to cache when available
 * - API errors: Propagate as Result.failure
 * - Missing data: Return empty list or null
 *
 * @property apiClient Ktor client for connpass API
 * @property eventDao Room DAO for local event storage
 */
class EventRepositoryImpl(
    private val apiClient: ConnpassApiClient,
    private val eventDao: EventDao
) : EventRepository {

    override suspend fun fetchEvents(userId: Long, forceRefresh: Boolean): Result<List<EventEntity>> {
        return try {
            // Clear cache if force refresh requested
            if (forceRefresh) {
                eventDao.deleteAll()
            }

            // Fetch from API
            val response = apiClient.getEvents(userId = userId, count = 100, order = 4)

            // Convert DTOs to entities
            val entities = response.events.map { dto ->
                EventEntity(
                    id = 0,  // auto-generated by Room
                    eventId = dto.eventId,
                    title = dto.title,
                    description = dto.description,
                    startedAt = parseInstant(dto.startedAt),
                    endedAt = parseInstant(dto.endedAt),
                    url = dto.eventUrl,
                    address = dto.address ?: "",
                    limit = dto.limit ?: 0,
                    accepted = dto.accepted,
                    waiting = dto.waiting
                )
            }

            // Cache to database (REPLACE strategy handles duplicates)
            eventDao.insertAll(entities)

            // Return success with cached entities (to get auto-generated IDs)
            Result.success(eventDao.getAllEventsOnce())

        } catch (e: ApiException) {
            // API error - try to return cached data as fallback
            val cachedEvents = eventDao.getAllEventsOnce()
            if (cachedEvents.isNotEmpty()) {
                // Return cached data with warning (wrapped in Result for consistency)
                Result.success(cachedEvents)
            } else {
                Result.failure(e)
            }
        } catch (e: Exception) {
            // Unexpected error - try cache fallback
            val cachedEvents = eventDao.getAllEventsOnce()
            if (cachedEvents.isNotEmpty()) {
                Result.success(cachedEvents)
            } else {
                Result.failure(NetworkException("Network error: ${e.message}", e))
            }
        }
    }

    override fun getEventsFromCache(): Flow<List<EventEntity>> {
        return eventDao.getAllEvents()
    }

    override suspend fun getEventsFromCacheOnce(): List<EventEntity> {
        return eventDao.getAllEventsOnce()
    }

    override suspend fun getEventById(eventId: Long): Result<EventEntity> {
        // Try cache first
        val cachedEvent = eventDao.getEventByConnpassId(eventId)
        if (cachedEvent != null) {
            return Result.success(cachedEvent)
        }

        // Cache miss - this would require fetching all events or a specific event endpoint
        // For now, return failure (PBI-2 focuses on list view, detail can fetch from cache)
        return Result.failure(Exception("Event not found in cache. Call fetchEvents() first."))
    }

    override suspend fun getEventByIdFromCache(eventId: Long): EventEntity? {
        return eventDao.getEventByConnpassId(eventId)
    }

    override suspend fun clearCache() {
        eventDao.deleteAll()
    }

    override suspend fun getCacheCount(): Int {
        return eventDao.getEventCount()
    }

    /**
     * Parse ISO 8601 datetime string to Instant.
     * Handles connpass API datetime format: "2024-12-25T19:00:00+09:00"
     *
     * @param dateTimeString ISO 8601 datetime string
     * @return Parsed Instant
     * @throws IllegalArgumentException if format is invalid
     */
    private fun parseInstant(dateTimeString: String): Instant {
        return try {
            Instant.parse(dateTimeString)
        } catch (e: IllegalArgumentException) {
            // Fallback: if parsing fails, return epoch (this shouldn't happen with valid connpass data)
            throw IllegalArgumentException("Invalid datetime format from API: $dateTimeString", e)
        }
    }
}

/**
 * Exception for network-related errors.
 * Will be refined in Task 2.6 with comprehensive error handling.
 */
class NetworkException(message: String, cause: Throwable? = null) : Exception(message, cause)
