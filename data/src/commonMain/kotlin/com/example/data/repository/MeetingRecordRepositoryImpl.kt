package com.example.data.repository

import com.example.data.database.dao.MeetingRecordDao
import com.example.data.database.entity.MeetingRecordEntity
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.first
import kotlinx.datetime.Clock

/**
 * Implementation of MeetingRecordRepository.
 *
 * Implementation by: data-layer-architect (coordinated by project-orchestrator)
 * PBI-4, Task 1.12: MeetingRecordRepositoryImpl implementation
 *
 * This repository manages meeting record persistence using Room database.
 * It handles duplicate detection, input validation, and error handling.
 *
 * @property meetingRecordDao Room DAO for meeting record operations
 */
class MeetingRecordRepositoryImpl(
    private val meetingRecordDao: MeetingRecordDao
) : MeetingRecordRepository {

    override suspend fun saveMeetingRecord(
        eventId: Long,
        userId: Long,
        nickname: String
    ): Result<Unit> {
        return try {
            // Validate inputs
            require(eventId > 0) { "Invalid event ID: $eventId" }
            require(userId > 0) { "Invalid user ID: $userId" }
            require(nickname.isNotBlank()) { "Nickname cannot be empty" }

            // Create entity with current timestamp
            val entity = MeetingRecordEntity(
                id = 0,  // auto-generated by Room
                eventId = eventId,
                userId = userId,
                nickname = nickname.trim(),
                createdAt = Clock.System.now()
            )

            // Insert with IGNORE strategy (returns -1 if duplicate)
            val insertId = meetingRecordDao.insert(entity)

            if (insertId == -1L) {
                // Duplicate record (UNIQUE constraint violated)
                Result.failure(
                    DuplicateRecordException(
                        "Meeting record already exists for event $eventId and user $userId"
                    )
                )
            } else {
                Result.success(Unit)
            }
        } catch (e: IllegalArgumentException) {
            // Validation error
            Result.failure(e)
        } catch (e: Exception) {
            // Unexpected database error
            Result.failure(
                Exception("Failed to save meeting record: ${e.message}", e)
            )
        }
    }

    override fun getAllMeetingRecords(): Flow<List<MeetingRecordEntity>> {
        return meetingRecordDao.getAllMeetingRecords()
    }

    override fun getMeetingRecordsByEvent(eventId: Long): Flow<List<MeetingRecordEntity>> {
        return meetingRecordDao.getMeetingRecordsByEvent(eventId)
    }

    override fun getMeetingRecordsByUser(userId: Long): Flow<List<MeetingRecordEntity>> {
        return meetingRecordDao.getMeetingRecordsByUser(userId)
    }

    override suspend fun getMeetingRecordById(id: Long): MeetingRecordEntity? {
        return try {
            meetingRecordDao.getMeetingRecordById(id).first()
        } catch (e: Exception) {
            // Flow is empty or error occurred
            null
        }
    }

    override suspend fun deleteMeetingRecord(meetingRecord: MeetingRecordEntity): Result<Unit> {
        return try {
            meetingRecordDao.delete(meetingRecord)
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(
                Exception("Failed to delete meeting record: ${e.message}", e)
            )
        }
    }

    override suspend fun meetingRecordExists(eventId: Long, userId: Long): Boolean {
        return try {
            meetingRecordDao.getMeetingRecordCount(eventId, userId) > 0
        } catch (e: Exception) {
            // On error, assume doesn't exist (safe default)
            false
        }
    }
}

/**
 * Exception thrown when attempting to create a duplicate meeting record.
 * The database UNIQUE constraint on (eventId, userId) prevents duplicates.
 */
class DuplicateRecordException(message: String) : Exception(message)
