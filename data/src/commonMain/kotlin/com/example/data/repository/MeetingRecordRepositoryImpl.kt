package com.example.data.repository

import com.example.data.database.dao.MeetingRecordDao
import com.example.data.database.dao.TagDao
import com.example.data.database.entity.MeetingRecordEntity
import com.example.data.database.entity.MeetingRecordTagCrossRef
import com.example.data.database.entity.MeetingRecordWithTags
import com.example.data.database.entity.TagEntity
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.first
import kotlinx.datetime.Clock

/**
 * Implementation of MeetingRecordRepository.
 *
 * Implementation by: data-layer-architect (coordinated by project-orchestrator)
 * PBI-4, Task 1.12: MeetingRecordRepositoryImpl implementation
 * PBI-5, Task 1.20: Added tag and notes operations implementation
 *
 * This repository manages meeting record persistence using Room database.
 * It handles duplicate detection, input validation, error handling, and tag management.
 *
 * @property meetingRecordDao Room DAO for meeting record operations
 * @property tagDao Room DAO for tag operations
 */
class MeetingRecordRepositoryImpl(
    private val meetingRecordDao: MeetingRecordDao,
    private val tagDao: TagDao
) : MeetingRecordRepository {

    override suspend fun saveMeetingRecord(
        eventId: Long,
        userId: Long,
        nickname: String
    ): Result<Unit> {
        return try {
            // Validate inputs
            require(eventId > 0) { "Invalid event ID: $eventId" }
            require(userId > 0) { "Invalid user ID: $userId" }
            require(nickname.isNotBlank()) { "Nickname cannot be empty" }

            // Create entity with current timestamp
            val entity = MeetingRecordEntity(
                id = 0,  // auto-generated by Room
                eventId = eventId,
                userId = userId,
                nickname = nickname.trim(),
                createdAt = Clock.System.now()
            )

            // Insert with IGNORE strategy (returns -1 if duplicate)
            val insertId = meetingRecordDao.insert(entity)

            if (insertId == -1L) {
                // Duplicate record (UNIQUE constraint violated)
                Result.failure(
                    DuplicateRecordException(
                        "Meeting record already exists for event $eventId and user $userId"
                    )
                )
            } else {
                Result.success(Unit)
            }
        } catch (e: IllegalArgumentException) {
            // Validation error
            Result.failure(e)
        } catch (e: Exception) {
            // Unexpected database error
            Result.failure(
                Exception("Failed to save meeting record: ${e.message}", e)
            )
        }
    }

    override fun getAllMeetingRecords(): Flow<List<MeetingRecordEntity>> {
        return meetingRecordDao.getAllMeetingRecords()
    }

    override fun getMeetingRecordsByEvent(eventId: Long): Flow<List<MeetingRecordEntity>> {
        return meetingRecordDao.getMeetingRecordsByEvent(eventId)
    }

    override fun getMeetingRecordsByUser(userId: Long): Flow<List<MeetingRecordEntity>> {
        return meetingRecordDao.getMeetingRecordsByUser(userId)
    }

    override suspend fun getMeetingRecordById(id: Long): MeetingRecordEntity? {
        return try {
            meetingRecordDao.getMeetingRecordById(id).first()
        } catch (e: Exception) {
            // Flow is empty or error occurred
            null
        }
    }

    override suspend fun deleteMeetingRecord(meetingRecord: MeetingRecordEntity): Result<Unit> {
        return try {
            meetingRecordDao.delete(meetingRecord)
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(
                Exception("Failed to delete meeting record: ${e.message}", e)
            )
        }
    }

    override suspend fun meetingRecordExists(eventId: Long, userId: Long): Boolean {
        return try {
            meetingRecordDao.getMeetingRecordCount(eventId, userId) > 0
        } catch (e: Exception) {
            // On error, assume doesn't exist (safe default)
            false
        }
    }

    // ==================== PBI-5: Meeting Notes & Tagging Operations ====================

    override suspend fun updateMeetingRecord(
        id: Long,
        notes: String?,
        tagNames: List<String>
    ): Result<Unit> {
        return try {
            // Validate meeting record exists
            val existingRecord = meetingRecordDao.getMeetingRecordById(id).first()
                ?: return Result.failure(Exception("Meeting record not found: $id"))

            // Update meeting record with new notes
            val updatedRecord = existingRecord.copy(notes = notes?.trim())
            meetingRecordDao.updateMeetingRecord(updatedRecord)

            // Clear all existing tag associations
            meetingRecordDao.deleteAllTagsForMeetingRecord(id)

            // Associate tags (create tag if doesn't exist, then link)
            tagNames.forEach { tagName ->
                if (tagName.isNotBlank()) {
                    // Get or create tag
                    val existingTag = tagDao.getTagByName(tagName.trim())
                    val tagId = if (existingTag != null) {
                        existingTag.id
                    } else {
                        // Create new tag
                        val newTag = TagEntity(
                            id = 0,  // auto-generated
                            name = tagName.trim(),
                            createdAt = Clock.System.now()
                        )
                        tagDao.insertTag(newTag)
                    }

                    // Create association (if insertTag returned valid ID or existing tag found)
                    if (tagId > 0) {
                        meetingRecordDao.insertMeetingRecordTagCrossRef(
                            MeetingRecordTagCrossRef(
                                meetingRecordId = id,
                                tagId = tagId
                            )
                        )
                    } else {
                        // insertTag returned -1, tag already exists, fetch it
                        val tag = tagDao.getTagByName(tagName.trim())
                        if (tag != null) {
                            meetingRecordDao.insertMeetingRecordTagCrossRef(
                                MeetingRecordTagCrossRef(
                                    meetingRecordId = id,
                                    tagId = tag.id
                                )
                            )
                        }
                    }
                }
            }

            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(
                Exception("Failed to update meeting record: ${e.message}", e)
            )
        }
    }

    override fun getMeetingRecordWithTags(id: Long): Flow<MeetingRecordWithTags?> {
        return meetingRecordDao.getMeetingRecordWithTags(id)
    }

    override fun getAllMeetingRecordsWithTags(): Flow<List<MeetingRecordWithTags>> {
        return meetingRecordDao.getAllMeetingRecordsWithTags()
    }

    override fun getAllTags(): Flow<List<TagEntity>> {
        return tagDao.getAllTags()
    }

    override suspend fun deleteMeetingRecordById(id: Long): Result<Unit> {
        return try {
            meetingRecordDao.deleteMeetingRecordById(id)
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(
                Exception("Failed to delete meeting record: ${e.message}", e)
            )
        }
    }
}

/**
 * Exception thrown when attempting to create a duplicate meeting record.
 * The database UNIQUE constraint on (eventId, userId) prevents duplicates.
 */
class DuplicateRecordException(message: String) : Exception(message)
